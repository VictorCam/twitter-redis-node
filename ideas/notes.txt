==negate exclusives==
REDIS: ==search by username and/or tag and/or score== HASH:FPOST:xxx
userid=KV
username
postname
tags --is_scrap can be implemented client side
score
image [small]
is_exclusive --if 0:false then allow=>search and if 1:true then remove=>search
post=KV

KVROCKS: HASH:USERID:xxx
post:xxx
userid
username
email
image
desc
join_date -UNIX?
is_verified
is_admin- delete, update, verify
is_superadmin, admin/unadmin, delete, update, modify, verify,
is_deleted


KVROCKS: HASH:POST:xxx
username
filecontent
postname
text
score
tags
views
is_exclusive
is_sketch
comment_settings [redis graph]
likes [likes->users]
dislikes [dislikes->users HIDDEN] 
[post->comments]


KVROCKS: KEY

==
https://stackoverflow.com/questions/23507200/good-practices-for-designing-monthly-subscription-system-in-database
==

//interesting read
==
https://redis.io/topics/latency
==

==check if username or email is taken [login]==
redis: search username or email
kvrocks: if(user||email) disallow : make account

==updating a users personal information==
redis: update hash username and/or email
kvrocks: update userid username and/or email


//get the post permission if allowed to post certain things
//add this feature later

//should belong to one section of a shard
//if we delete a post we can at least delete the post
//perhaps the nestedcomment and znestedcomments

//consider how to reduce the loops required on certain api endpoints
//since nodejs is a single threaded.
//we can use a queue to process the requests

//keep note when storing a ton of things client sided
//also keep note when there is a memory leak in server and/or client

# We will run it with docker-compose up --build -d --scale redis=3. It will bring up 5 containers (1 worker, 1 Envoy Proxy and 3 Redis).


#axios alt when working with the store in the client
# @bundled-es-modules/axios
https://thisthat.dev/

//on userid add [balance]

//on each post add [revenue]

//api to search users you follow public/private

//view a post

//count the post 1 for a user (do not count duplicates) but count it for ad api counts

//api via stripe for buying ad and api to see and accept ad api and api using seedweed false

//in the FUTURE make the api for doing image searches

//do an api for voting/bidding (multiple bids at the same time)/commission status/forms/transfering money

//maybe allow text posts on timelines but txt files do not generate revenue

//api for users who are open for commission api that shows ads sfw or nsfw dpeneidngo on account on account settings and age


feed-live
active or not
voice chat- but anyone who follows you can see you and join you 
multiple accounts
woofin woofin
like discord but with inactiviity

art posts /videos// vid stream exclustive posts
watch list of tags --prevent abuse (post tag verfiers) -> limit large abitrary taggging -> allow 10 last of tags to watch

we can do a subscription using a hash where we have the user check if their subscription:id exists then with the key of the username and the timestamp
if it does not exist then that means that we don't have a subscription in place and if it does but it is expired then we tell them that their subscription is expired but they can renew it if they need to

how are we going to search things up if we don't have any sort of way to find things


I was thinking about having different sorted sets for posting
when a user posts a post there will be different sorted sets according to the preferences of the user
one will contain posts and rehowls
another will contain just posts
or we could make an api call that combines them together (with the expense of doing more network calls)

rename the word "READ" on the feed to something thats akin to "posts that are left to read"
synonyms for the word "posts that are left to read"

https://javascript.info/websocket#chat-example

pipeline commands when they pertaining to ONE user (belong to one shard)